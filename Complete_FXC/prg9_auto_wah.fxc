; Default program 9
;
; Auto-wah
; mono in/out
;
; pot0 = sensitivity
; pot1 = Q
;

.rn       temp      r0
.rn       input     r1
.rn       inlp      r2
.rn       hp        r3
.rn       bp        r4
.rn       lp        r5
.rn       kf        r6
.rn       kq        r7
.rn       envlp     r8
.rn       env       r9
.rn       sens      r10
.rn       bright    r14

.equ env_coeff 0.0006 * (2^31 - 1)

; adjust pot0 for sensitivity
cpy_cs    acc32, pot0_smth
multri    acc32, 0.8
addsi     acc32, 0.2
cpy_cc    sens, acc32

; adjust pot1 for Q control
; range from about 0.8 to 0.05 for damping
cpy_cs    acc32, pot1_smth        ; Read in pot1
addsi     acc32, -1.0             ; acc32 ranges -1 to 0
multri    acc32, 0.75             ; acc32 ranges -0.75 to 0
neg       acc32                   ; acc32 ranges 0.75 to 0
addsi     acc32, 0.05             ; acc32 ranges 0.8 to 0.05
cpy_cc    kq, acc32

cpy_cs    input, in0              ; read the input


; ##### Envelope follower #####
wrdld     temp, env_coeff>>16       ; load in lp coefficient
ori       temp, env_coeff&0xffff
cpy_cc    temp, acc32             ; coeff in temp now
multrr    input, input            ; square the signal
subs      acc32, envlp            ; in - lp
multrr    acc32, temp             ; *K
adds      acc32, envlp            ; + lp
cpy_cc    envlp, acc32            ; save to lp
; square root
log2      acc32                   ; log2
sra       acc32, 1                ; /2 to take square root
exp2      acc32                   ; and back to linear
multrr    sens, acc32
sls       acc32,2                 ; multiply by 4 to control SVF
cpy_cc    env, acc32              ; save to env
; ##### End envelope follower #####


; now the SVF using env as Kf rather than kf reg
; first a LP FIR with a null at Fs/2 to help make the filter stable
; and allow a wider range of coefficients
sra       input, 1                ; in/2
cpy_cc    temp, acc32             ; save to temp
adds      acc32, inlp             ; in/2 + input LP
cpy_cc    input, acc32            ; save to in
cpy_cc    inlp, temp              ; save in/2 to input LP
; now the svf
multrr    env, bp                 ; Kf * BP
adds      lp, acc32               ; + LP
cpy_cc    lp, acc32               ; save to LP
multrr    kq, bp                  ; Kq * BP
adds      lp, acc32               ; LP + Kq * BP
subs      input, acc32            ; IN - (LP + Kq * BP)
cpy_cc    hp, acc32               ; save to HP
multrr    env, hp                 ; Kf * HP
adds      bp, acc32               ; + BP
cpy_cc    bp, acc32               ; Save to BP


cpy_sc    out0, bp                ; output to channels 0 and 1
cpy_sc    out1, bp


; The PWM value becomes updated every 256 samples translating to a
; PWM frequency of 125Hz @32k with 8 bit resolution.
; While this is not exactly a high resolution PWM it might still
; good enough for generating basic control voltages in some applications.
; For driving the LEDs in this case it is perfectly enough.
cpy_cs    acc32, samplecnt        ; Get the sample counter
andi      acc32, 0xFF             ; Mask b[7:0]
jnz       acc32, doPWM            ;

; Reload new PWM value from LFO0_s into "bright"
sra       env, 23                 ; shift the PWM value in place
cpy_cc    bright, acc32           ; save it

doPWM:
; Performing the decrement prior to driving the LED makes sure
; that the LED can go completly off.
addi      bright, -1              ; subtract 1 from the on count
cpy_cc    bright, acc32           ; Save updated "bright"
xor       acc32, acc32            ; Clear acc32 for the LED off case
jneg      bright, doLED           ;
ori       acc32, 1                ; Set acc32[0] for the LED on case

doLED:
set       user0|0, acc32          ; set the usr1 output per the acc32 LSB
