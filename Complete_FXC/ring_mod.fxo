; Processed by FXCore Preprocessor V:2025.2.0.0 7 Jul 2025 - 14:52:30 -07:00
; 03 Sep 2025 7:38:31 -07:00
; Generated by GooeyCore V:2025.2
; 3 Sep 2025, 07:38:27
.MREG MR0 0
.MREG MR1 0
.MREG MR2 0
// @g_util.get_sfr(POT0,MR3)
/****************************************************
*        GET SFR INTO MREG
*
*****************************************************/
CPY_CS	R0, POT0 //  -- replacing IN with POT0
CPY_MC	MR3, R0 //  -- replacing OUT with MR3
// end inclusion library g_util --  subroutine get_sfr

// @g_util.get_sfr(IN0,MR8)
/****************************************************
*        GET SFR INTO MREG
*
*****************************************************/
CPY_CS	R0, IN0 //  -- replacing IN with IN0
CPY_MC	MR8, R0 //  -- replacing OUT with MR8
// end inclusion library g_util --  subroutine get_sfr

// @g_util.scale_shift(MR3,MR4,0.1,0)
/****************************************************
*        (IN*SCALE)+SHIFT
*
*****************************************************/
CPY_CM	R0, MR3		 //  -- replacing IN with MR3
MULTRI	R0, 0.1 //  -- replacing SCALE with 0.1
ADDSI	ACC32, 0 //  -- replacing SHIFT with 0
CPY_MC	MR4, ACC32	 //  -- replacing OUT with MR4
// end inclusion library g_util --  subroutine scale_shift

// @g_util.scale_shift(MR3,MR5,0.9,0.1)
/****************************************************
*        (IN*SCALE)+SHIFT
*
*****************************************************/
CPY_CM	R0, MR3		 //  -- replacing IN with MR3
MULTRI	R0, 0.9 //  -- replacing SCALE with 0.9
ADDSI	ACC32, 0.1 //  -- replacing SHIFT with 0.1
CPY_MC	MR5, ACC32	 //  -- replacing OUT with MR5
// end inclusion library g_util --  subroutine scale_shift

// @g_util.Select(MR4,MR5,MR6,SW2)
/****************************************************
*        SELECT INPUT BASED ON SWITCH
*
*****************************************************/
CPY_CS	R0, SWITCH
ANDI	R0, SW2 //  -- replacing SW with SW2
JNZ	ACC32,	SEL_S1_10
CPY_CM	R1, MR4 //  -- replacing IN0 with MR4
JMP	DO_OUT_10
SEL_S1_10: CPY_CM	R1, MR5 //  -- replacing IN1 with MR5
DO_OUT_10: CPY_MC	MR6, R1	 //  -- replacing OUT with MR6
// end inclusion library g_util --  subroutine Select

// @g_util.lfo(MR6,MR0,MR7,MR1,MR2,1,1500,32768,0)
/****************************************************
*        LFO WITH SIN/TRI/SAW OUT
*
*****************************************************/
; LOAD VALUES
WRDLD	R0, ((2*PI()*1500/32768-2*PI()*1/32768)*(2^31-1))>>16  //  -- replacing FMAX with 1500 -- replacing FS with 32768 -- replacing FMIN with 1 -- replacing FS with 32768
ORI	R0, ((2*PI()*1500/32768-2*PI()*1/32768)*(2^31-1))&0XFFFF //  -- replacing FMAX with 1500 -- replacing FS with 32768 -- replacing FMIN with 1 -- replacing FS with 32768
CPY_CC	R0, ACC32
WRDLD	R1, ((2*PI()*1/32768)*(2^31-1))>>16  //  -- replacing FMIN with 1 -- replacing FS with 32768
ORI	R1, ((2*PI()*1/32768)*(2^31-1))&0XFFFF //  -- replacing FMIN with 1 -- replacing FS with 32768
CPY_CC	R1, ACC32
CPY_CM	R2, MR0 //  -- replacing PHASE with MR0
CPY_CM	R3, MR1 //  -- replacing SIN with MR1
CPY_CM	R4, MR2 //  -- replacing COS with MR2
WRDLD	R5, ((1500-1)*2^32/32768)>>16  //  -- replacing FMAX with 1500 -- replacing FMIN with 1 -- replacing FS with 32768
ORI	R5, ((1500-1)*2^32/32768)&0XFFFF //  -- replacing FMAX with 1500 -- replacing FMIN with 1 -- replacing FS with 32768
CPY_CC	R5, ACC32
WRDLD	R6, (1*2^32/32768)>>16  //  -- replacing FMIN with 1 -- replacing FS with 32768
ORI	R6, (1*2^32/32768)&0XFFFF //  -- replacing FMIN with 1 -- replacing FS with 32768
CPY_CC	R6, ACC32
// CHECK IF SIN AND COS ARE INITIALIZED, IF NOT SET INITIAL VALUES
OR	R3, R4	
JNZ	ACC32,	GO_11// NOPE, JUMP AWAY
CPY_CC	R3, ACC32
WRDLD	R4, 0X7FFF
ORI	R4, 0XFFFF
CPY_CC	R4, ACC32
GO_11: 
; CALCULATE THE PHASE INCREMENT FOR SIN/COS
CPY_CM	ACC32, MR6		 //  -- replacing FREQUENCY with MR6
MULTRR	ACC32, ACC32			
MULTRR	ACC32, R0				
ADDS	ACC32, R1          
CPY_CC	R15, ACC32			
; NOW FOR RAMP/TRI/SQUARE
CPY_CM	ACC32, MR6		 //  -- replacing FREQUENCY with MR6
MULTRR	ACC32, ACC32			
MULTRR	ACC32, R5				
ADDS	ACC32, R6          
ADD	ACC32, R2            
CPY_CC	R2, ACC32            
CPY_MC	MR0, R2 //  -- replacing PHASE with MR0
; SINE WAVE
MULTRR	R4, R15		
ADDS	ACC32, R3	
CPY_CC	R3, ACC32
MULTRR	R3, R15		
SUBS	R4, ACC32	
CPY_MC	MR1, R3 //  -- replacing SIN with MR1
CPY_MC	MR2, ACC32 //  -- replacing COS with MR2
; SELECT WAVE FORM
CPY_CS	R15, SWITCH
SR	R15, 0 //  -- replacing SW_SHIFT with 0
ANDI	ACC32, SW0|SW1
CPY_CC	R15, ACC32
XORI	R15, 0X0
JZ	ACC32,	DO_SIN_11
XORI	R15, 0X1
JZ	ACC32,	DO_SAW_11
XORI	R15, 0X2
JZ	ACC32,	DO_TRI_11
; SQUARE WAVE
; EITHER +1 OR 0 BASED ON SIGN OF PHASE REGISTER
WRDLD	ACC32, 0X7FFF           
ORI	ACC32, 0XFFFF
JGEZ	R2,	SET_SQ_11; IF PHASE IS POSITIVE JUMP
NEG	ACC32            
SET_SQ_11: 
JMP	DO_SCALE_11
; SAWTOOTH WAVE
; THE PHASE COUNTER REGISTER IS A SAWTOOTH SO JUST USE IT
DO_SAW_11: 
CPY_CC	ACC32, R2	
JMP	DO_SCALE_11
; TRIANGLE WAVE
; WE CAN CREATE A TRIANGLE BY TAKING THE ABS OF THE SAWTOOTH (PHASE REG)
DO_TRI_11: 
ABS	R2                   
ADDSI	ACC32, -0.5		
SLS	ACC32, 1
JMP	DO_SCALE_11
; SIN WAVE
DO_SIN_11: 
CPY_CC	ACC32, R3
; OUTPUT RESULT
DO_SCALE_11: 
CPY_MC	MR7, ACC32 //  -- replacing WAVE_OUT with MR7
// end inclusion library g_util --  subroutine lfo

// @g_util.get_sfr(POT1,MR11)
/****************************************************
*        GET SFR INTO MREG
*
*****************************************************/
CPY_CS	R0, POT1 //  -- replacing IN with POT1
CPY_MC	MR11, R0 //  -- replacing OUT with MR11
// end inclusion library g_util --  subroutine get_sfr

// @g_util.A*B(MR8,MR7,MR9)
/****************************************************
*        A*B
*
*****************************************************/
CPY_CM	R0, MR8	 //  -- replacing SIG1 with MR8
CPY_CM	R1, MR7 //  -- replacing SIG2 with MR7
MULTRR	R0, R1
CPY_MC	MR9, ACC32	 //  -- replacing SIGOUT with MR9
// end inclusion library g_util --  subroutine A*B

// @g_util.2_mix(MR8,MR9,MR11,MR10)
/****************************************************
*        MIX 2 SIGNALS FROM 100% SIG1/0% SIG2 TO
*        0% SIG1/100% SIG2 BASED ON MREG VALUE
*****************************************************/
CPY_CM	R0, MR8	 //  -- replacing SIG1 with MR8
CPY_CM	R1, MR9 //  -- replacing SIG2 with MR9
CPY_CM	R2, MR11 //  -- replacing MIXCON with MR11
MULTRR	R1, R2		
CPY_CC	R1, ACC32	
NEG	R2		
CPY_CC	R2, ACC32
WRDLD	ACC32, 0X7FFF	
ORI	ACC32, 0XFFFF
ADDS	R2, ACC32	
MULTRR	R0, ACC32	
ADDS	R1, ACC32	
CPY_MC	MR10, ACC32	 //  -- replacing SIGOUT with MR10
// end inclusion library g_util --  subroutine 2_mix

// @g_util.put_sfr(OUT0,MR10)
/****************************************************
*        PUT MREG INTO SFR
*
*****************************************************/
CPY_CM	R0, MR10 //  -- replacing IN with MR10
CPY_SC	OUT0, R0 //  -- replacing OUT with OUT0
// end inclusion library g_util --  subroutine put_sfr

