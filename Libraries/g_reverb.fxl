<library>
	<name>g_reverb</name>
	<desc>Basic library of reverbs for the FXCore DSP from Experimental Noize</desc>
	<lib_color>255, 166, 0</lib_color>
	<lib_text_color>255,255,255</lib_text_color>
	<sub>
		<name>small_reverb</name>
		<desc>Small room reverb, mono in/out, uses an LFO to eliminate standing waves</desc>
		<param>
			<name>Time</name>
			<side>T</side>
			<type>MREG</type>
			<desc>Controls reverb time</desc>
		</param>
		<param>
			<name>LP_Filt</name>
			<side>T</side>
			<type>MREG</type>
			<desc>Controls low-pass filter in reverb loop</desc>
		</param>
		<param>
			<name>LP_reg</name>
			<side>B</side>
			<type>MREG</type>
			<desc>MREG to hold LP value between samples, just connect an MREG here</desc>
		</param>
		<param>
			<name>In</name>
			<side>L</side>
			<type>MREG</type>
			<desc>Input signal</desc>
		</param>
		<param>
			<name>Out</name>
			<side>R</side>
			<type>MREG</type>
			<desc>Reverb out, mix with dry signal</desc>
		</param>
		<param>
			<name>LFO</name>
			<type>STR</type>
			<desc>Put LFO (LFO0, LFO2, etc) to use</desc>
		</param>
		<param>
			<name>LFOF</name>
			<side>B</side>
			<type>SFR</type>
			<desc>Put LFO frequency control reg(LFO0_F, LFO2_F, etc) must match LFO in param</desc>
		</param>
		<code>
			/****************************************************
			*        Small room reverb  
			*        
			*****************************************************/
			.mem    ap1         420           ; all-pass block 1
			.mem    ap2         867           ; all-pass block 2
			.mem    ap3         1578          ; all-pass block 3
			.mem    ap4         390           ; all-pass block 4
			.mem    apc1        3402          ; loop all-pass 1
			.mem    apc2        2202          ; loop all-pass 2
			.mem    dc          7678          ; loop delay

			wrdld     r0, ((2*pi()*0.45)*(2^31-1)/32768)>>16
			ori       r0, ((2*pi()*0.45)*(2^31-1)/32768)&amp;0xffff
			cpy_sc    LFOF, acc32
			cpy_cm    r0, Time
			log2      r0                      ; log2 into acc32
			sra       acc32, 1                ; /2 for sq root
			exp2      acc32                   ; back to linear
			multri    acc32, 0.8              ; range 0 to 0.8
			wrdld     r0, 0.1*32767           ; put 0.1 in r0
			adds      acc32, r0               ; range 0.1 to 0.9
			cpy_cc    r10, acc32
			wrdld     r11, 0x4000
			cpy_cm    acc32, LP_Filt
			multri    acc32, 0.805
			wrdld     r0, 28737               ; put 0.877... into r0
			subs      r0, acc32
			cpy_cc    r13, acc32
			; get input to to first string of APs
			cpy_cm    acc32, In
			sra       acc32, 1
			apra      r11, ap1#
			aprb      r11, ap1
			apra      r11, ap2#
			aprb      r11, ap2
			apra      r11, ap3#
			aprb      r11, ap3
			apa       0.65, ap4#
			apa       -0.65, ap4
			cpy_cc    r9, acc32             ; put to the side for now
			rddel     acc32, dc#
			cpy_cm    r0, LP_reg
			subs      acc32, r0               ; lp filter so: acc32 = input - lp
			multrr    acc32, r13              ; acc32*K2
			adds      acc32, r0               ; acc32+lp
			cpy_mc    LP_reg, acc32           ; write back to lp
			multrr    r10, acc32              ; multiply by reverb time
			adds      acc32, r9             ; add in input all-pass
			apa       0.6, apc1#
			apb       -0.6, apc1
			apa       0.6, apc2#
			apb       -0.6, apc2
			wrdel     dc, acc32
			clracc64                          ; clear the 64-bit accumulator
			machid    0.8, dc                 ; add in taps from delays
			machid    0.7, dc+4315
			machid    0.6, dc#
			sat64     acc32                   ; copy upper 32 bits to acc32 and saturate
			cpy_mc    Out, acc32
			xor       acc32, acc32
			ori       acc32, 50
			cpy_cc    r15, acc32
			chr       LFO|sin,dc+100
			wrdel     dc+200, acc32
		</code>
	</sub>
	<sub>
		<name>plate_reverb</name>
		<desc>Plate reverb, uses 2 LFOs</desc>
		<param>
			<name>Time</name>
			<side>T</side>
			<type>MREG</type>
			<desc>Controls reverb time</desc>
		</param>
		<param>
			<name>LP_Filt</name>
			<side>T</side>
			<type>MREG</type>
			<desc>Controls low-pass filter in reverb loop</desc>
		</param>
		<param>
			<name>Ringing</name>
			<side>T</side>
			<type>MREG</type>
			<desc>Controls ringing in reverb loop</desc>
		</param>
		<param>
			<name>LP_reg</name>
			<side>B</side>
			<type>MREG</type>
			<desc>MREG to hold LP value between samples, just connect an MREG here</desc>
		</param>
		<param>
			<name>LP1</name>
			<side>B</side>
			<type>MREG</type>
			<desc>MREG to hold LP1 value between samples, just connect an MREG here</desc>
		</param>
		<param>
			<name>LP2</name>
			<side>B</side>
			<type>MREG</type>
			<desc>MREG to hold LP2 value between samples, just connect an MREG here</desc>
		</param>
		<param>
			<name>LP3</name>
			<side>B</side>
			<type>MREG</type>
			<desc>MREG to hold LP3 value between samples, just connect an MREG here</desc>
		</param>
		<param>
			<name>LP4</name>
			<side>B</side>
			<type>MREG</type>
			<desc>MREG to hold LP4 value between samples, just connect an MREG here</desc>
		</param>
		<param>
			<name>InA</name>
			<side>L</side>
			<type>MREG</type>
			<desc>Input signal A</desc>
		</param>
		<param>
			<name>InB</name>
			<side>L</side>
			<type>MREG</type>
			<desc>Input signal B</desc>
		</param>
		<param>
			<name>OutA</name>
			<side>R</side>
			<type>MREG</type>
			<desc>Reverb out B, mix with dry signal</desc>
		</param>
		<param>
			<name>OutB</name>
			<side>R</side>
			<type>MREG</type>
			<desc>Reverb out B, mix with dry signal</desc>
		</param>
		<param>
			<name>LFOA</name>
			<type>STR</type>
			<desc>Put LFOA (LFO0, LFO2, etc) to use</desc>
		</param>
		<param>
			<name>LFOB</name>
			<type>STR</type>
			<desc>Put LFOB (LFO0, LFO2, etc) to use</desc>
		</param>
		<param>
			<name>LFOA_F</name>
			<side>B</side>
			<type>SFR</type>
			<desc>Put LFOA frequency control reg(LFO0_F, LFO2_F, etc) must match LFOA in param</desc>
		</param>
		<param>
			<name>LFOB_F</name>
			<side>B</side>
			<type>SFR</type>
			<desc>Put LFOB frequency control reg(LFO0_F, LFO2_F, etc) must match LFOB in param</desc>
		</param>
		<code>
			/****************************************************
			*        Plate reverb  
			*        
			*****************************************************/
			.mem    api1l       224           ;left input all passes
			.mem    api2l       430
			.mem    api3l       856
			.mem    api4l       1089
			.mem    api1r       156           ;right input all passes
			.mem    api2r       530
			.mem    api3r       956
			.mem    api4r       1289
			.mem    apd1        2301          ;loop all passes
			.mem    apd2        2902
			.mem    apd3        3171
			.mem    apd4        2401
			.mem    del1        3620          ;loop delays
			.mem    del2        4591
			.mem    del3        4387
			.mem    del4        3679
			wrdld     r0, ((2^31-1)*(2*pi()*0.477)/32768)>>16
			ori       r0, ((2^31-1)*(2*pi()*0.477)/32768)&amp;0xffff
			cpy_sc    LFOA_F, acc32
			wrdld     r0, ((2^31-1)*(2*pi()*0.382)/32768)>>16
			ori       r0, ((2^31-1)*(2*pi()*0.382)/32768)&amp;0xffff
			cpy_sc    LFOB_F, acc32
			cpy_cm    r0, Time                ; read pot0 into r0
			log2      r0                      ; log2 into acc32
			sra       acc32, 1                ; /2 for sq root
			exp2      acc32                   ; back to linear
			multri    acc32, 0.8              ; range 0 to 0.8
			wrdld     r0, 0.1*32767           ; put 0.1 in r0
			adds      acc32, r0               ; range 0.1 to 0.9
			cpy_cc    r2, acc32               ; save as krt
			cpy_cm    acc32, InA              ; read in input A
			sra       acc32, 2                ; shift right by 2 for /4
			apa       0.6, api1l#            ; first input ap
			apb       -0.6, api1l
			apa       0.6, api2l#            ; second input ap
			apb       -0.6, api2l
			apa       0.6, api3l#            ; third input ap
			apb       -0.6, api3l
			apa       0.6, api4l#            ; fourth input ap
			apb       -0.6, api4l
			cpy_cc    r5, acc32              ; save in lap
			cpy_cm    acc32, InB              ; read in input B
			sra       acc32, 2                ; shift right by 2 for /4
			apa       0.6, api1r#            ; first input ap
			apb       -0.6, api1r
			apa       0.6, api2r#            ; second input ap
			apb       -0.6, api2r
			apa       0.6, api3r#            ; third input ap
			apb       -0.6, api3r
			apa       0.6, api4r#            ; fourth input ap
			apb       -0.6, api4r
			cpy_cc    r6, acc32              ; save in rap
			cpy_cm    r0, LP_reg                 ; the code left the result in acc to add to lup so we
			adds      acc32, r0               ; load into a different core reg then add
			apa       0.6, apd1#              ; loop ap
			apb       -0.6, apd1
			wrdel     del1, acc32             ; write result to head of del1
			wrdld     acc32, 0x7fff
			ori       acc32, 0xffff           ; load 0.99.. into acc32
			cpy_cm    r0, LP_Filt
			subs      acc32, r0
			cpy_cc    r0, acc32
			rddel     acc32, del1#            ; read tail of del1
			cpy_cm    r11, lp1
			subs      acc32, r11
			multrr    acc32, r0
			adds      r11, acc32
			cpy_mc    lp1, acc32
			multrr    acc32, r2              ; multiply by krt coefficient
			adds      acc32, r5              ; load into a different core reg then add
			apa       0.6, apd2#              ; loop ap
			apb       -0.6, apd2
			wrdel     del2, acc32             ; write result to head of del2
			rddel     acc32, del2#            ; read tail of del2
			cpy_cm    r12, lp2
			subs      acc32, r12
			multrr    acc32, r0
			adds      r12, acc32
			cpy_mc    lp2, acc32
			multrr    acc32, r2              ; multiply by krt coefficient
			adds      acc32, r6              ; load into a different core reg then add
			apa       0.6, apd3#              ; loop ap
			apb       -0.6, apd3
			wrdel     del3, acc32             ; write result to head of del3
			rddel     acc32, del3#            ; read tail of del3
			cpy_cm    r13, lp3
			subs      acc32, r13
			multrr    acc32, r0
			adds      r13, acc32
			cpy_mc    lp3, acc32
			multrr    acc32, r2              ; multiply by krt coefficient
			adds      acc32, r5              ; load into a different core reg then add
			apa       0.6, apd4#              ; loop ap
			apb       -0.6, apd4
			wrdel     del4, acc32             ; write result to head of del4
			rddel     acc32, del4#            ; read tail of del4
			cpy_cm    r14, lp4
			subs      acc32, r14
			multrr    acc32, r0
			adds      r14, acc32
			cpy_mc    lp4, acc32
			cpy_mc    LP_reg, acc32              ; save for next time through loop
			clracc64                          ; clear the 64-bit accumulator
			machid    0.8, del1+201           ; add in taps from delays
			machid    0.7, del2+1345
			machid    0.6, del3+897
			machid    0.5, del4+1780
			sat64     acc32                   ; copy upper 32 bits to acc32
			cpy_mc    OutA, acc32             ; and write to the left DAC output
			clracc64                          ; clear the 64-bit accumulator
			machid    0.8, del1+1201          ; add in taps from delays
			machid    0.7, del2+145
			machid    0.6, del3+487
			machid    0.5, del4+780
			sat64     acc32                   ; copy upper 32 bits to acc32
			cpy_mc    OutB, acc32             ; and write to the right DAC output
			cpy_cm    r0, ringing
			wrdld     acc32, 39
			multrr    acc32, r0
			cpy_cc    r15, acc32
			chr       LFOA|sin, apd1+40
			wrdel     apd1+90, acc32
			chr       LFOA|cos, apd2+30
			wrdel     apd2+80, acc32
			wrdld     acc32, 34
			multrr    acc32, r0
			cpy_cc    r15, acc32
			chr       LFOB|sin, apd3+40
			wrdel     apd3+90, acc32
			chr       LFOB|cos, apd4+50
			wrdel     apd4+100, acc32
		</code>
	</sub>
</library>